<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Lucas">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Java开发常用的加密算法"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="Sakura"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="Sakura" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Sakura</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/image21.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Java开发常用的加密算法</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/Conjugasion" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Lucas</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-04-23</span>
            <span class="time">16:20:15</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">#加密算法</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a><strong>加密算法分类</strong></h3><p>加密算法可以分为<code>单向加密</code>和<code>双向加密</code>，双向加密又分为<code>对称加密</code>和<code>非对称加密</code>。<br>双向加密是将明文加密后形成密文，可以通过算法还原成明文。<br>单向加密只是对信息进行了摘要计算，不能通过算法生成明文。</p>
<h3 id="双向加密之对称加密"><a href="#双向加密之对称加密" class="headerlink" title="双向加密之对称加密"></a><strong>双向加密之对称加密</strong></h3><p><code>对称加密</code>：采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。需要对加密和解密使用相同密钥的加密算法。由于其速度，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。加密算法是一组规则，规定如何进行加密和解密。因此对称式加密本身不是安全的。常用的对称加密有：<code>DES</code>、<code>IDEA</code>、<code>RC2</code>、<code>RC4</code>、<code>SKIPJACK</code>、<code>RC5</code>、<code>AES</code>算法等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//KeyGenerator 提供对称密钥生成器的功能，支持各种算法</span><br><span class="line">private KeyGenerator keygen;</span><br><span class="line"> </span><br><span class="line">//SecretKey 负责保存对称密钥</span><br><span class="line">private SecretKey deskey;</span><br><span class="line"> </span><br><span class="line">//Cipher负责完成加密或解密工作</span><br><span class="line">private Cipher c;</span><br><span class="line"> </span><br><span class="line">//该字节数组负责保存加密的结果</span><br><span class="line">private byte[] cipherByte;</span><br></pre></td></tr></table></figure>

<h3 id="双向加密之非对称加密"><a href="#双向加密之非对称加密" class="headerlink" title="双向加密之非对称加密"></a><strong>双向加密之非对称加密</strong></h3><p><code>非对称加密</code>：非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥 （privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。最常用的非对称加密算法是<code>RSA</code>(安全性很好)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author tangdongfan</span><br><span class="line"> * @date 2020/4/23 18:45</span><br><span class="line"> * 基于非对称算法RSA加密/解密用户Pin</span><br><span class="line"> * 公钥加密，私钥解密</span><br><span class="line"> */</span><br><span class="line">public class EncryptUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static final String PRIVATE_KEY = &quot;privateKey&quot;;</span><br><span class="line">    public static final String PUBLIC_KEY = &quot;publicKey&quot;;</span><br><span class="line"></span><br><span class="line">    // 生成公钥和私钥</span><br><span class="line">    public static Map&lt;String, Key&gt; generatorKeys() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Map&lt;String,Key&gt; keys = new HashMap&lt;&gt;();</span><br><span class="line">            //KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象</span><br><span class="line">            KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            //初始化密钥对生成器，密钥大小为1024位</span><br><span class="line">            keyPairGen.initialize(1024);</span><br><span class="line">            //生成一个密钥对，保存在keyPair中</span><br><span class="line">            KeyPair keyPair = keyPairGen.generateKeyPair();</span><br><span class="line">            //得到私钥</span><br><span class="line">            Key privateKey = keyPair.getPrivate();</span><br><span class="line">            //得到公钥</span><br><span class="line">            Key publicKey = keyPair.getPublic();</span><br><span class="line">            keys.put(PRIVATE_KEY, privateKey);</span><br><span class="line">            keys.put(PUBLIC_KEY, publicKey);</span><br><span class="line">            return keys;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加密算法</span><br><span class="line">    public static byte[] encrypt(Key publicKey, String srcMsg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] srcMsgByte = srcMsg.getBytes();</span><br><span class="line">            //Cipher基于RSA进行加密</span><br><span class="line">            Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">            //根据公钥，对Cipher对象进行初始化</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            //加密</span><br><span class="line">            return cipher.doFinal(srcMsgByte);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解密算法</span><br><span class="line">    public static String decrypt(Key privateKey, byte[] encryptMsgByte) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //Cipher基于RSA进行解密</span><br><span class="line">            Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">            //根据公钥，对Cipher对象进行初始化</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            //解密</span><br><span class="line">            byte[] srcMsgByte = cipher.doFinal(encryptMsgByte);</span><br><span class="line">            return new String(srcMsgByte);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a><strong>单向加密</strong></h3><p>一旦数据被加密就没有办法颠倒这一过程。因此密码的验证包括对用户输入内容的重新加密，并将它与保存的密文进行比对，看是否匹配。一种简单的单向加密方式是<code>MD5</code>校验码。<br><code>MD5</code>：Message-Digest Algorithm 5（信息-摘要算法 5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串)。<br>除了MD5以外，其中比较有名的还有<code>sha-1</code>、<code>RIPEMD</code>以及<code>Haval</code>等 </p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

